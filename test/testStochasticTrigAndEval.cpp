
#include <set>
#include <string>
#include <vector>

#include "GenerativeTriggerGenerator2.h"
//#include "StochasticGrammar.h"
#include "TriggerSequencer.h"
//#include <random>
/*********************************************************************************************************
 * TriggerSequencer
 **********************************************************************************************************/

// test event at zero fires at zero
#if 0
static void ts0() {
    TriggerSequencer::Event seq[] =
        {
            {TriggerSequencer::TRIGGER, 0},
            {TriggerSequencer::END, 100}};
    TriggerSequencer ts(seq);

    ts.clock();
    assert(ts.getTrigger());

    ts.clock();
    assert(!ts.getTrigger());
}
#endif

// test trigger at 1 happens at 1
#if 0
static void ts1() {
    TriggerSequencer::Event seq[] =
        {
            {TriggerSequencer::TRIGGER, 1},
            {TriggerSequencer::END, 0}};
    TriggerSequencer ts(seq);

    ts.clock();
    assert(!ts.getTrigger());

    ts.clock();
    assert(ts.getTrigger());

    ts.clock();
    assert(!ts.getTrigger());

    ts.clock();
    assert(!ts.getTrigger());
}
#endif

// 4 clock loop: delay 4, trigger, end
#if 0
static void ts2() {
    TriggerSequencer::Event seq[] =
        {
            {TriggerSequencer::TRIGGER, 4},
            {TriggerSequencer::END, 0}};
    TriggerSequencer ts(seq);

    bool firstTime = true;
    // first time through, 4 clocks of nothing. then clock, 0,0,0
    for (int i = 0; i < 4; ++i) {
        ts.clock();
        if (firstTime) {
            assert(!ts.getTrigger());
            assert(!ts.getEnd());
            firstTime = false;
        } else {
            //printf("second time around, t=%d e=%d\n", ts.getTrigger(), ts.getEnd());

            // second time around we finally see the trigger

            assert(ts.getTrigger());

            // second time around, need to clock the end of the last time
            assert(ts.getEnd());
            ts.reset(seq);             // start it up again
            assert(!ts.getTrigger());  // resetting should not set us up for a trigger
        }
        ts.clock();
        assert(!ts.getTrigger());
        assert(!ts.getEnd());
        ts.clock();
        assert(!ts.getTrigger());
        assert(!ts.getEnd());

        ts.clock();
        assert(!ts.getTrigger());
        //	assert(ts.getEnd());

        //	ts.reset(seq);
    }
}
#endif

// test trigger seq qith
// 4 clock loop: trigger, delay 4 end
#if 0
static void ts3() {
    TriggerSequencer::Event seq[] =
        {
            {TriggerSequencer::TRIGGER, 0},
            {TriggerSequencer::END, 4}};
    TriggerSequencer ts(seq);

    bool firstLoop = true;
    for (int i = 0; i < 4; ++i) {
        //printf("--- loop ----\n");

        // 1

        ts.clock();
        if (firstLoop) {
            assert(ts.getTrigger());
            // we just primed loop at top, so it's got a ways
            assert(!ts.getEnd());
            firstLoop = false;
        } else {
            // second time around, need to clock the end of the last time
            assert(ts.getEnd());
            ts.reset(seq);            // start it up again
            assert(ts.getTrigger());  // resetting should have set us up for a trigger
        }
        // 2
        ts.clock();
        assert(!ts.getTrigger());
        assert(!ts.getEnd());
        // 3
        ts.clock();
        assert(!ts.getTrigger());
        assert(!ts.getEnd());
        // 4
        ts.clock();
        assert(!ts.getTrigger());
        assert(!ts.getEnd());
    }
}
#endif

// test trigger seq with straight ahead 4/4 as generated by a grammar
#if 0
static void ts4() {
    TriggerSequencer::Event seq[] =
        {
            {TriggerSequencer::TRIGGER, 0},
            {TriggerSequencer::TRIGGER, 4},
            {TriggerSequencer::TRIGGER, 4},
            {TriggerSequencer::TRIGGER, 4},
            {TriggerSequencer::END, 4}};
    TriggerSequencer ts(seq);

    //bool firstLoop = true;
    for (int i = 0; i < 100; ++i) {
        bool firstTime = (i == 0);
        // repeating pattern of trigg, no, no, no
        for (int j = 0; j < 4; ++j) {
            for (int k = 0; k < 4; ++k) {
                //	printf("test loop, i=%d, j=%d, k=%d\n", i, j, k);
                ts.clock();

                bool expectEnd = (k == 0) && (j == 0) && !firstTime;
                assert(ts.getEnd() == expectEnd);
                if (ts.getEnd()) {
                    ts.reset(seq);
                }
                assert(ts.getTrigger() == (k == 0));
            }
        }
    }
}
#endif

/********************************************************************************************
* GenerativeTriggerGenerator
**********************************************************************************************/

// test that we get some clocks and some not
#if 0
static void gtg0() {
    auto grammar = StochasticGrammar::getDemoGrammar(StochasticGrammar::DemoGrammar::demo);
    AudioMath::RandomUniformFunc r = AudioMath::random();
    GenerativeTriggerGenerator2 gtg(r, grammar);

    bool yes = false;
    bool no = false;
    for (int i = 0; i < 100000; ++i) {
        if (gtg.clock())
            yes = true;
        else
            no = true;

        if (yes && no) {
            //printf("clocked at %d\n", i);
            return;
        }
    }
    assert(false);
}
#endif

// test that we get everything in even quarter notes
// could bring this over
static void gtg1() {
    //assert(false);
    //SQINFO("we could port gtg1 test to new arch");
#if 0
    GKEY key = init1();
    std::set<int> counts;

    GenerativeTriggerGenerator gtg(AudioMath::random(), rules, numRules, key);

    int ct = 0;
    for (int i = 0; i < 10000; ++i) {
        bool b = gtg.clock();
        if (b) {
            //printf("clocked at %d\n", ct);
            counts.insert(ct);
            ct = 0;
        }
        ct++;
    }
    //counts.insert(50);
    assert(!counts.empty());
    for (std::set<int>::iterator it = counts.begin(); it != counts.end(); ++it) {
        int c = *it;

        if ((c % PPQ) != 0) {
            //printf("PPQ=%d, c modePPQ =%d\n", PPQ, (c % PPQ));
            //printf("2ppq = %d, 4ppq=%d\n", 2 * PPQ, 4 * PPQ);
            assert(false);
        }
    }
#endif
}

//*********************** Evaluator *************************

class TestEvaluator : public StochasticProductionRule::EvaluationState {
public:
    TestEvaluator(AudioMath::RandomUniformFunc xr) : StochasticProductionRule::EvaluationState(xr) {
    }

    void writeSymbol(const StochasticNote& sym) override {
        notes.push_back(sym);
    }

    size_t getNumSymbols() {
        return notes.size();
    }
    std::vector<StochasticNote> notes;

private:
};

static void testEvaluatorGeneratesSomething() {
    auto grammar = StochasticGrammar::getDemoGrammar(StochasticGrammar::DemoGrammar::simple);
    TestEvaluator es(AudioMath::random());
    es.grammar = grammar;

    StochasticProductionRule::evaluate(es, es.grammar->getRootRule());
    assert(es.getNumSymbols() > 0);
}

static void testEvaluatorGeneratesQuartersOnlyForTest() {
    auto grammar = StochasticGrammar::getDemoGrammar(StochasticGrammar::DemoGrammar::quarters);
    TestEvaluator es(AudioMath::random());
    es.grammar = grammar;

    for (int i = 0; i < 100; ++i) {
        StochasticProductionRule::evaluate(es, es.grammar->getRootRule());
        assertEQ(es.getNumSymbols(), 2);        // this grammar always makes two quarter notes
        for (auto note : es.notes) {
            assertEQ(note.duration, StochasticNote::ppq);
        }
        es.notes.clear();
    }
}

static void testEvaluatorGenerates25Fixed(float fakeRandomNumber, int expectedDur) {
    assert(fakeRandomNumber >= 0);
    assert(fakeRandomNumber <= 1);
    auto grammar = StochasticGrammar::getDemoGrammar(StochasticGrammar::DemoGrammar::x25);
    TestEvaluator es([fakeRandomNumber]() {
        return fakeRandomNumber;
        });
    es.grammar = grammar;
    std::map<int, int> notes;

    for (int i = 0; i < 100; ++i) {
        StochasticProductionRule::evaluate(es, es.grammar->getRootRule());
        for (auto note : es.notes) {
            if (notes.find(note.duration) == notes.end()) {
                notes[note.duration] = 1;
            }
            else {
                notes[note.duration] += 1;
            }
        }
        es.notes.clear();
    }
    // all same dur
    assertEQ(notes.size(), 1);
    for (auto entry : notes) {
        //SQINFO("dur %d, got %d", entry.first, entry.second);
        assert(entry.first == expectedDur);
    }
}

static void testEvaluatorGenerates25_0() {
    //SQINFO("====  run with gmr 25, rand = 0");
   
    testEvaluatorGenerates25Fixed(0, StochasticNote::ppq);
    testEvaluatorGenerates25Fixed(.24f, StochasticNote::ppq);

    testEvaluatorGenerates25Fixed(.26f, StochasticNote::ppq / 2);
    testEvaluatorGenerates25Fixed(.49f, StochasticNote::ppq / 2);

    testEvaluatorGenerates25Fixed(.51f, StochasticNote::ppq / 4);
    testEvaluatorGenerates25Fixed(.74f, StochasticNote::ppq / 4);

    testEvaluatorGenerates25Fixed(.76f, StochasticNote::ppq * 2);
    testEvaluatorGenerates25Fixed(1.f, StochasticNote::ppq * 2);
}

#if 0
static void testEvaluatorGenerates25Fixed(float fakeRandomNumber, std::map<int, int>& notes) {
    assert(fakeRandomNumber >= 0);
    assert(fakeRandomNumber <= 1);
    auto grammar = StochasticGrammar::getDemoGrammar(StochasticGrammar::DemoGrammar::x25);
    TestEvaluator es([fakeRandomNumber]() {
        return fakeRandomNumber;
        });
    es.grammar = grammar;

    for (int i = 0; i < 100; ++i) {
        StochasticProductionRule::evaluate(es, es.grammar->getRootRule());
        for (auto note : es.notes) {
            if (notes.find(note.duration) == notes.end()) {
                notes[note.duration] = 1;
            }
            else {
                notes[note.duration] += 1;
            }
        }
        es.notes.clear();
    }
}

static void testEvaluatorGenerates25_0() {
    //SQINFO("====  run with gmr 25, rand = 0");
    std::map<int, int> notes;
    testEvaluatorGenerates25Fixed(0,notes);
    assert(entry.size() > 0);
    for (auto entry : notes) {
        //SQINFO("dur %d, got %d", entry.first, entry.second);
        assert(entry.first == StochasticNote::ppq);
    }
}
#endif


static void testEvaluatorGenerates25() {
    auto grammar = StochasticGrammar::getDemoGrammar(StochasticGrammar::DemoGrammar::x25);
    TestEvaluator es(AudioMath::random());
    es.grammar = grammar;

    std::map<int, int> notes;

    const int iterations = 10000;
    for (int i = 0; i < iterations; ++i) {
        StochasticProductionRule::evaluate(es, es.grammar->getRootRule());
         for (auto note : es.notes) {
            //assertEQ(note.duration, StochasticNote::ppq);
            if (notes.find(note.duration) == notes.end()) {
                //assert(false);
                notes[note.duration] = 1;
            } else {
                notes[note.duration] += 1;
            }
        }
       
        es.notes.clear();
    }

#if 0
    for (auto it : notes) {
        //SQINFO("key=%d, value=%d", it.first, it.second);
    }
#endif

    const int expected = iterations / 4;
    for (auto entry : notes) {
        int duration = entry.first;
        int count = entry.second;
        switch (duration) {
        case 192:
            break;
        case 96:
            count /= 2;
            break;
        case 48:
            count /= 4;
            break;
        case 24:
            count /= 8;
            break;
        default:
            assert(false);
        }
        //SQINFO("dur %d, got %d (adj)", duration, count);
        assertClose(count, expected, 75);
    }
}


#if 0 // this is just for debugging
static void testEvaluatorGeneratesSimple(AudioMath::RandomUniformFunc rand, int iterations) {
    auto grammar = StochasticGrammar::getDemoGrammar(StochasticGrammar::DemoGrammar::simple);
    TestEvaluator es(rand);
    es.grammar = grammar;

    int last = 0;
    int longestRun = 0;
    int currentRun = 0;
   // const int iterations = 20;
    for (int i = 0; i < iterations; ++i) {
        StochasticProductionRule::evaluate(es, es.grammar->getRootRule());
#if 0
        //SQINFO("Iter %d", i);
         for (auto note : es.notes) {
             //SQINFO("  n=%s", note.toText().c_str());
         }
#endif
        //SQINFO(es.notes.size() > 1 ? "B" : "a");
         if (last == es.notes.size()) {
             currentRun++;
             currentRun = std::max(currentRun, 2);
         } else{
             currentRun = 0;
         }
         last = int(es.notes.size());
         longestRun = std::max(longestRun, currentRun);
         es.notes.clear();
    }
    //SQWARN("iter = %d, longest = %d", iterations, longestRun);

    
}


void testEvaluatorGeneratesSimple() {
    const int iterations = 1000000;
    //SQINFO("norm");
    testEvaluatorGeneratesSimple(AudioMath::random(), iterations);
    //SQINFO("better");
    testEvaluatorGeneratesSimple(AudioMath::random_better(), iterations);
    assert(false);
}
#endif

void testStochasticTrigAndEval() {

#if 0   // these tests worked on gmr3 branch. do we have new versions of all of them?
    ts0();
    ts1();
    ts2();
    ts3();
    ts4();

    gtg0();
#endif

    gtg1();

    // testGrammar1();
    testEvaluatorGeneratesSomething();
    testEvaluatorGeneratesQuartersOnlyForTest();
    testEvaluatorGenerates25_0();
    testEvaluatorGenerates25();
    // testEvaluatorGeneratesSimple();
}